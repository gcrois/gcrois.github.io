---
layout: post
title: "K#0001: KataIR Design"
author: Cade Brown
email: me@cade.site
categories: [kata]
tags: [kata, meta]
series: kata
thumb: /files/kata-logo.webp
---

an [intermediate representation (or IR)](https://en.wikipedia.org/wiki/Intermediate_representation) is a way of representing code in a format that is easy to parse, analyze, and transform. they're used in compilers to simplify the workflow and ease portability. for that reason, we are going to be designing an IR for kata and its languages, called KataIR

<!--more-->

for example, here are a few IRs used in popular compilers:

  * [GCC GIMPLE](https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html)
  * [LLVM IR](https://llvm.org/docs/LangRef.html)
  * [LLVM MLIR](https://mlir.llvm.org/)

but, we're going to create our own, since none of the existing solutions are satisfactory (it's too hard to write portable code in them, while retaining all the type information needed for developer tools)

## Enter: KataIR

KataIR is the intermediate representation meant for the Kata ecosystem. all kata languages can transpile themselves to KataIR (as `.kir` or `.kirb` files), which can in turn be ran on the KataVirtualMachine (`kvm`), or compiled for a specific platform/target (such as WebAssembly, x86, etc...)

### Goals

  * be easily generated by compilers, keeping metadata/debug information
  * completely cross platform (e.g. no 64/32 bit specification required, no ABI changes)
    * platform specific types can be used, but should be reducable to a standard type (i.e. `usize` -> `u32` or `u64` during lowering)
  * easily translated to LLVM IR, WebAssembly, or KVM format for execution
  * support entire type system (structures, unions, dynamic/virtual types)  
  * easily parsed by machines and humans
  * support exception handling

### Non-Goals

  * direct support for hardware specific instructions (this will be done in lower level passed with LLVM MLIR/IR)
  * direct support for specifying linking/ABI (it should be the target's native)

## Basic Design

this is a basic overview of KataIR, covering the major components and the textual syntax (`.kir` files). in the future, we will also include a binary format (`.kirb`), but for now we'll just focus on the textual format

for example, here is the infamous "hello, world" example:

```kir
<file
  name="helloworld.kir"
  <final
    "krt"
    type=module
    <import
      <const "krt">
    >
  >
  <func
    name="main"
    type=()->s32
    <block
      <call
        <attr
          <attr
            <ref "krt">
            <const "stdout">
          >
          <const "print">
        >
        <const "hello, world\n">
      >
      <ret
        <const 0 type=s32>
      >
    >
  >
>
```

the syntax is basically one big tree. each node in the tree is indicated by `<nodetype (...)>` (where `(...)` are either constants, `key=val` pairs, or other tree nodes). this allows us to describe program structure as an [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree).

here are some of the example nodes:

  * `<file name="foo.bar" ...>`: contents of a file parsed. this is typically a top level construct after a transpiler has ran
  * `<const (data)>`: represents a constant, unchangable, and immutable value, which can be an integer, string, floating point value, etc
  * `<ref (name)>`: represents a reference to a name, which can be local or global (or, it could be invalid...)
  * `<import ...>`: imports a module, by name. typically `...` is a `<const>` node with the name of the module being imported
    * however, this format also allows for dynamic/variable imports. however, these can't be optimized!
  * `<let (name) type=(type) (...)>`: declares a mutable variable with a given name and type, and an (optional) initial value
  * `<final (name) type=(type) (...)>`: declares an immutable (final) variable that cannot be reassigned. the initial value is required, as it is the only value
  * `<call ...>`: represents a function-like calling operation on function and arguments
  * `<attr ...>`: represents an attribute reference (i.e. `a.b`). nested attributes are represented via nested `<attr ...>` nodes
  * `<ret ...>`: represents a "return" from a function, which yields a value
  * `<block ...>`: represents a collection of other nodes which should be ran sequentially

## Metadata/Extras

each node in KataIR also has an attributes dictionary that can be used to store/encode flags, settings, metadata, locations, etc...

for example, consider the fibonacci function in `.kc`:

```kc
""" fib/init.kc - calculates fibonacci numbers

@author: Cade Brown <me@cade.site>
"""

func fib(x: u32)->u32 {
    if x < 2, ret x
    ret ...(x - 2) + ...(x - 1)
}

```

which is translated to the following `kir`:

```kir
<file
  name="init.kc"
  <func
    name="fib"
    type=(u32)->u32
    loc="@6,1:9,2"
    <block
      loc="@6,23:9,2"
      <if
        loc="@7,5:,13"
        <lt 
          loc="@7,8:13"
          <ref "x" loc="@7,8:,9"> 
          <const 2 loc="@7,12:,13">
        >
        <ret
          loc="@7,15:18"
          <ref "x" loc="@7,19:20">
        >
      >
      <ret 
        loc="@8,5:32"
        <add
          loc="@8,9:32"
          <recurse
            loc="@8,9:19"
            <sub
              loc="@8,13:18"
              <ref "x" loc="@8,13:14">
              <const 2 loc="@8,17:18">
            >
          >
          <recurse
            loc="@8,22:32"
            <sub
              loc="@8,26:37"
              <ref "x" loc="@8,26:27">
              <const 1 loc="@8,30:31">
            >
          >
        >
      >
    >
  >
>
```

here, we see that basically all of the relevant information for IDEs/developer tools to analyze the code, without actually having to parse it. this also allows for tree-based searches of code bases (check out [WorldSyntaxTree](https://github.com/utk-se/WorldSyntaxTree) for a real world example of this)

